import createDebug from 'debug';
import { isString, isObject, isRegExp, isFunction, isArray } from '@intlify/shared';
import { resolveModule, addPluginTemplate, addWebpackPlugin, extendWebpackConfig, addVitePlugin, resolveFiles, extendPages, templateUtils, defineNuxtModule, isNuxt2, isNuxt3, getNuxtVersion, addTemplate } from '@nuxt/kit';
import { dirname, resolve, parse } from 'pathe';
import defu from 'defu';
import { fileURLToPath } from 'url';
import VueI18nWebpackPlugin from '@intlify/unplugin-vue-i18n/webpack';
import VueI18nVitePlugin from '@intlify/unplugin-vue-i18n/vite';
import { localizeRoutes } from 'vue-i18n-routing';
import { genImport } from 'knitwork';

const distDir = dirname(fileURLToPath(import.meta.url));
const pkgDir = resolve(distDir, "..");
const pkgModulesDir = resolve(pkgDir, "./node_modules");

async function setupNuxtBridge(nuxt) {
  nuxt.options.alias["vue-i18n"] = resolveModule("vue-i18n-legacy/dist/vue-i18n.esm.js", {
    paths: nuxt.options.modulesDir
  });
  nuxt.options.build.transpile.push("vue-i18n");
  const vueI18nBridgePath = nuxt.options.dev ? "vue-i18n-bridge/dist/vue-i18n-bridge.esm-bundler.js" : "vue-i18n-bridge/dist/vue-i18n-bridge.runtime.esm-bundler.js";
  nuxt.options.alias["vue-i18n-bridge"] = resolveModule(vueI18nBridgePath, {
    paths: nuxt.options.modulesDir
  });
  nuxt.options.build.transpile.push("vue-i18n-bridge");
  addPluginTemplate({
    filename: "runtime/bridge.plugin.mjs",
    src: resolve(distDir, "runtime/bridge.plugin.mjs")
  });
}

async function setupAutoImports(nuxt) {
}

const debug$3 = createDebug("@nuxtjs/i18n:bundler");
async function extendBundler(hasLocaleFiles, langPath) {
  try {
    const webpack = await import('webpack').then((m) => m.default || m);
    if (hasLocaleFiles && langPath) {
      addWebpackPlugin(VueI18nWebpackPlugin({
        include: [resolve(langPath, "./**")]
      }));
    }
    extendWebpackConfig((config) => {
      config.plugins.push(new webpack.DefinePlugin({
        __VUE_I18N_FULL_INSTALL__: "true",
        __VUE_I18N_LEGACY_API__: "true",
        __INTLIFY_PROD_DEVTOOLS__: "false"
      }));
    });
  } catch (e) {
    debug$3(e.message);
  }
  if (hasLocaleFiles && langPath) {
    addVitePlugin(VueI18nVitePlugin({
      include: [resolve(langPath, "./**")]
    }));
  }
}

async function setupNuxt3(nuxt) {
  const vueI18nPath = nuxt.options.dev ? "vue-i18n/dist/vue-i18n.esm-bundler.js" : "vue-i18n/dist/vue-i18n.runtime.esm-bundler.js";
  nuxt.options.alias["vue-i18n"] = resolveModule(vueI18nPath, {
    paths: nuxt.options.modulesDir
  });
  nuxt.options.build.transpile.push("vue-i18n");
  addPluginTemplate({
    filename: "runtime/nuxt3.plugin.mjs",
    src: resolve(distDir, "runtime/nuxt3.plugin.mjs")
  });
}

const NUXT_I18N_MODULE_ID = "@nuxtjs/i18n";
const STRATEGY_PREFIX = "prefix";
const STRATEGY_PREFIX_EXCEPT_DEFAULT = "prefix_except_default";
const STRATEGY_PREFIX_AND_DEFAULT = "prefix_and_default";
const STRATEGY_NO_PREFIX = "no_prefix";
const STRATEGIES = {
  PREFIX: STRATEGY_PREFIX,
  PREFIX_EXCEPT_DEFAULT: STRATEGY_PREFIX_EXCEPT_DEFAULT,
  PREFIX_AND_DEFAULT: STRATEGY_PREFIX_AND_DEFAULT,
  NO_PREFIX: STRATEGY_NO_PREFIX
};
const DEFAULT_OPTIONS = {
  vueI18n: void 0,
  locales: [],
  defaultLocale: "",
  defaultDirection: "ltr",
  routesNameSeparator: "___",
  trailingSlash: false,
  defaultLocaleRouteNameSuffix: "default",
  strategy: STRATEGY_PREFIX_EXCEPT_DEFAULT,
  lazy: false,
  langDir: null,
  detectBrowserLanguage: {
    alwaysRedirect: false,
    cookieCrossOrigin: false,
    cookieDomain: null,
    cookieKey: "i18n_redirected",
    cookieSecure: false,
    fallbackLocale: "",
    redirectOn: "root",
    useCookie: true
  },
  baseUrl: "",
  pages: {},
  onBeforeLanguageSwitch: () => ({}),
  onLanguageSwitched: () => null
};

function formatMessage(message) {
  return `${NUXT_I18N_MODULE_ID} ${message}`;
}
function getNormalizedLocales(locales) {
  locales = locales || [];
  const normalized = [];
  for (const locale of locales) {
    if (isString(locale)) {
      normalized.push({ code: locale });
    } else {
      normalized.push(locale);
    }
  }
  return normalized;
}
async function resolveLocales(path, locales) {
  const files = await resolveFiles(path, "**/*{json,json5,yaml,yml}");
  return files.map((file) => {
    const parsed = parse(file);
    const locale = findLocales(locales, parsed.base);
    return locales == null ? {
      path: file,
      file: parsed.base,
      code: parsed.name
    } : Object.assign({ path: file }, locale);
  });
}
function findLocales(locales, filename) {
  const ret = locales.find((locale) => isObject(locale) && locale.file === filename);
  return ret != null ? ret : null;
}

const debug$2 = createDebug("@nuxtjs/i18n:pages");
function setupPages(options, nuxt, additionalOptions = {
  isBridge: false,
  localeCodes: []
}) {
  let includeUprefixedFallback = nuxt.options.target === "static";
  nuxt.hook("generate:before", () => {
    debug$2("called generate:before hook");
    includeUprefixedFallback = true;
  });
  const pagesDir = nuxt.options.dir && nuxt.options.dir.pages ? nuxt.options.dir.pages : "pages";
  const { trailingSlash } = nuxt.options.router;
  debug$2(`pagesDir: ${pagesDir}, tailingSlash: ${trailingSlash}`);
  extendPages((pages) => {
    debug$2("pages making ...", pages);
    const localizedPages = localizeRoutes(pages, {
      ...options,
      includeUprefixedFallback,
      optionsResolver: getRouteOptionsResolver(options.pages, pagesDir, options.defaultLocale)
    });
    pages.splice(0, pages.length);
    pages.unshift(...localizedPages);
    debug$2("... made pages", pages);
  });
}
function getRouteOptionsResolver(pages, pagesDir, defaultLocale) {
  return (route, localeCodes) => {
    const options = {
      locales: localeCodes,
      paths: {}
    };
    const pattern = new RegExp(`${pagesDir}/`, "i");
    const chunkName = route.chunkName ? route.chunkName.replace(pattern, "") : route.name;
    const pageOptions = chunkName ? pages[chunkName] : void 0;
    if (pageOptions === false) {
      return null;
    }
    if (!pageOptions) {
      return options;
    }
    options.locales = options.locales.filter((locale) => pageOptions[locale] !== false);
    for (const locale of options.locales) {
      const customLocalePath = pageOptions[locale];
      if (typeof customLocalePath === "string") {
        options.paths[locale] = customLocalePath;
        continue;
      }
      const customDefaultLocalePath = pageOptions[defaultLocale];
      if (typeof customDefaultLocalePath === "string") {
        options.paths[locale] = customDefaultLocalePath;
      }
    }
    return options;
  };
}

const debug$1 = createDebug("@nuxtjs/i18n:gen");
function generateLoaderOptions(lazy, langDir, options = {}) {
  let genCode = "";
  const localeInfo = options.localeInfo || [];
  const { fallbackLocale } = isObject(options.nuxtI18nOptions?.vueI18n) ? options.nuxtI18nOptions?.vueI18n : {};
  const syncLocaleFiles = /* @__PURE__ */ new Set();
  const asyncLocaleFiles = /* @__PURE__ */ new Set();
  if (langDir) {
    if (fallbackLocale && isString(fallbackLocale)) {
      const localeObject = localeInfo.find((l) => l.code === fallbackLocale);
      if (localeObject) {
        syncLocaleFiles.add(localeObject);
      }
    }
    for (const locale of localeInfo) {
      if (!syncLocaleFiles.has(locale) && !asyncLocaleFiles.has(locale)) {
        (lazy ? asyncLocaleFiles : syncLocaleFiles).add(locale);
      }
    }
  }
  const importMapper = /* @__PURE__ */ new Map();
  for (const { code, path } of syncLocaleFiles) {
    importMapper.set(code, templateUtils.importName(`locale_${code}`));
    genCode += `${genImport(path, templateUtils.importName(`locale_${code}`))}
`;
  }
  genCode += `${Object.entries(options).map(([rootKey, rootValue]) => {
    if (rootKey === "nuxtI18nOptions") {
      let genCodes = `export const resolveNuxtI18nOptions = async (context) => {
`;
      genCodes += `  const ${rootKey} = Object({})
`;
      for (const [key, value] of Object.entries(rootValue)) {
        if (key === "vueI18n") {
          const optionLoaderVariable = `${key}OptionsLoader`;
          genCodes += `  const ${optionLoaderVariable} = ${isObject(value) ? `async (context) => ${toCode(value)}
` : isString(value) ? `async (context) => import(${toCode(value)}).then(r => (r.default || r)(context))
` : `async (context) => ${toCode({})}
`}`;
          genCodes += `  ${rootKey}.${key} = await ${optionLoaderVariable}(context)
`;
        } else {
          genCodes += `  ${rootKey}.${key} = ${toCode(value)}
`;
        }
      }
      genCodes += `  return nuxtI18nOptions
`;
      genCodes += `}
`;
      return genCodes;
    } else if (rootKey === "nuxtI18nOptionsDefault") {
      return `export const ${rootKey} = Object({${Object.entries(rootValue).map(([key, value]) => {
        return `${key}: ${toCode(value)}`;
      }).join(`,`)}})
`;
    } else if (rootKey === "nuxtI18nInternalOptions") {
      return `export const ${rootKey} = Object({${Object.entries(rootValue).map(([key, value]) => {
        return `${key}: ${toCode(value)}`;
      }).join(`,`)}})
`;
    } else if (rootKey === "localeInfo") {
      let codes = `export const loadMessages = async () => {
`;
      codes += `  const messages = Object({})
`;
      if (langDir) {
        for (const { code } of syncLocaleFiles) {
          codes += `  messages[${toCode(code)}] = ${importMapper.get(code)}
`;
        }
        for (const { code, path } of asyncLocaleFiles) {
          codes += `  messages[${toCode(code)}] = await import(${toCode(path)} /* webpackChunkName: ${toCode(path)} */).then(r => r.default || r)
`;
        }
      }
      codes += `  return Promise.resolve(messages)
`;
      codes += `}
`;
      return codes;
    } else {
      return `export const ${rootKey} = ${toCode(rootValue)}
`;
    }
  }).join("\n")}`;
  debug$1("generate code", genCode);
  return genCode;
}
function stringifyObj(obj) {
  return `Object({${Object.entries(obj).map(([key, value]) => `${JSON.stringify(key)}:${toCode(value)}`).join(`,`)}})`;
}
function toCode(code) {
  if (code === null) {
    return `null`;
  }
  if (code === void 0) {
    return `undefined`;
  }
  if (isString(code)) {
    return JSON.stringify(code);
  }
  if (isRegExp(code) && code.toString) {
    return code.toString();
  }
  if (isFunction(code) && code.toString) {
    return `(${code.toString()})`;
  }
  if (isArray(code)) {
    return `[${code.map((c) => toCode(c)).join(`,`)}]`;
  }
  if (isObject(code)) {
    return stringifyObj(code);
  }
  return code + ``;
}

const debug = createDebug("@nuxtjs/i18n:module");
const module = defineNuxtModule({
  meta: {
    name: NUXT_I18N_MODULE_ID,
    configKey: "i18n"
  },
  defaults: {},
  async setup(i18nOptions, nuxt) {
    const options = defu(i18nOptions, DEFAULT_OPTIONS);
    debug("options", options);
    checkOptions(options);
    if (isNuxt2(nuxt)) {
      await setupNuxtBridge(nuxt);
    } else if (isNuxt3(nuxt)) {
      await setupNuxt3(nuxt);
    } else {
      throw new Error(formatMessage(`Cannot support nuxt version: ${getNuxtVersion(nuxt)}`));
    }
    const langPath = isString(options.langDir) ? resolve(nuxt.options.srcDir, options.langDir) : null;
    debug("langDir path", langPath);
    const normalizedLocales = getNormalizedLocales(options.locales);
    const hasLocaleFiles = normalizedLocales.length > 0;
    const localeCodes = normalizedLocales.map((locale) => locale.code);
    const localeInfo = langPath != null ? await resolveLocales(langPath, normalizedLocales) : [];
    debug("localeInfo", localeInfo);
    options.vueI18n = isObject(options.vueI18n) ? options.vueI18n : isString(options.vueI18n) ? resolve(nuxt.options.rootDir, options.vueI18n) : {};
    if (options.strategy !== STRATEGIES.NO_PREFIX && localeCodes.length) {
      await setupPages(options, nuxt, { isBridge: isNuxt2(nuxt), localeCodes });
    }
    nuxt.options.alias["@intlify/shared"] = resolveModule("@intlify/shared/dist/shared.esm-bundler.js", {
      paths: nuxt.options.modulesDir
    });
    nuxt.options.build.transpile.push("@intlify/shared");
    nuxt.options.alias["@intlify/vue-router-bridge"] = resolveModule("@intlify/vue-router-bridge/lib/index.mjs", {
      paths: [pkgModulesDir, ...nuxt.options.modulesDir]
    });
    nuxt.options.build.transpile.push("@intlify/vue-router-bridge");
    nuxt.options.alias["@intlify/vue-i18n-bridge"] = resolveModule("@intlify/vue-i18n-bridge/lib/index.mjs", {
      paths: [pkgModulesDir, ...nuxt.options.modulesDir]
    });
    nuxt.options.build.transpile.push("@intlify/vue-i18n-bridge");
    nuxt.options.alias["vue-i18n-routing"] = resolveModule("vue-i18n-routing/dist/vue-i18n-routing.es.js", {
      paths: [pkgModulesDir, ...nuxt.options.modulesDir]
    });
    nuxt.options.build.transpile.push("vue-i18n-routing");
    const i18nPath = addTemplate({
      filename: "i18n.mjs",
      src: resolve(distDir, "runtime/composables.mjs")
    });
    nuxt.options.alias["#i18n"] = i18nPath.dst;
    addTemplate({
      filename: "i18n.internal.mjs",
      src: resolve(distDir, "runtime/internal.mjs")
    });
    addTemplate({
      filename: "i18n.utils.mjs",
      src: resolve(distDir, "runtime/utils.mjs")
    });
    addTemplate({
      filename: "i18n.options.mjs",
      write: true,
      getContents: () => {
        return generateLoaderOptions(options.lazy, langPath, {
          localeCodes,
          localeInfo,
          nuxtI18nOptions: options,
          nuxtI18nOptionsDefault: DEFAULT_OPTIONS,
          nuxtI18nInternalOptions: {
            __normalizedLocales: normalizedLocales
          }
        });
      }
    });
    await setupAutoImports();
    await extendBundler(hasLocaleFiles, langPath);
  }
});
function checkOptions(options) {
  if (options.lazy && !options.langDir) {
    throw new Error(formatMessage('When using the "lazy" option you must also set the "langDir" option.'));
  }
  if (options.langDir) {
    const locales = options.locales || [];
    if (!locales.length || isString(locales[0])) {
      throw new Error(formatMessage('When using the "langDir" option the "locales" must be a list of objects.'));
    }
    for (const locale of locales) {
      if (isString(locale) || !locale.file) {
        throw new Error(formatMessage(`All locales must be objects and have the "file" property set when using "langDir".
Found none in:
${JSON.stringify(locale, null, 2)}.`));
      }
    }
  }
}

export { module as default };
