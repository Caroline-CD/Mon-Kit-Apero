import { createUnplugin } from 'unplugin';
import { normalize, parse } from 'pathe';
import createDebug from 'debug';
import fg from 'fast-glob';
import { isString, isArray, isEmptyObject, isNumber, assign } from '@intlify/shared';
import { createFilter } from '@rollup/pluginutils';
import { generateJSON, generateYAML } from '@intlify/bundle-utils';
import { parse as parse$1 } from '@vue/compiler-sfc';
import JSON5 from 'json5';
import yaml from 'js-yaml';
import { promises } from 'fs';

function parseVueRequest(id) {
  const [filename, rawQuery] = id.split(`?`, 2);
  const params = new URLSearchParams(rawQuery);
  const ret = {};
  const langPart = Object.keys(Object.fromEntries(params)).find((key) => /lang\./i.test(key));
  ret.vue = params.has("vue");
  ret.global = params.has("global");
  ret.src = params.has("src");
  ret.raw = params.has("raw");
  if (params.has("type")) {
    ret.type = params.get("type");
  }
  if (params.has("blockType")) {
    ret.blockType = params.get("blockType");
  }
  if (params.has("index")) {
    ret.index = Number(params.get("index"));
  }
  if (params.has("locale")) {
    ret.locale = params.get("locale");
  }
  if (langPart) {
    const [, lang] = langPart.split(".");
    ret.lang = lang;
  } else if (params.has("lang")) {
    ret.lang = params.get("lang");
  }
  if (params.has("issuerPath")) {
    ret.issuerPath = params.get("issuerPath");
  }
  return {
    filename,
    query: ret
  };
}

function createBridgeCodeGenerator(source, query) {
  return () => {
    const data = convert(source, query.lang);
    let value = JSON.parse(data);
    if (isString(query.locale)) {
      value = Object.assign({}, { [query.locale]: value });
    }
    return JSON.stringify(value).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\\/g, "\\\\").replace(/\u0027/g, "\\u0027");
  };
}
function convert(source, lang) {
  switch (lang) {
    case "yaml":
    case "yml":
      const data = yaml.load(source);
      return JSON.stringify(data, void 0, "	");
    case "json5":
      return JSON.stringify(JSON5.parse(source));
    default:
      return source;
  }
}

function warn(...args) {
  console.warn(`[unplugin-vue-i18n] `, ...args);
}
function error(...args) {
  console.error(`[unplugin-vue-i18n] `, ...args);
}
async function getRaw(path) {
  return promises.readFile(path, { encoding: "utf-8" });
}
function raiseError(message) {
  throw new Error(`[unplugin-vue-i18n] ${message}`);
}

const INTLIFY_BUNDLE_IMPORT_ID = "@intlify/unplugin-vue-i18n/messages";
const INTLIFY_BUNDLE_IMPORT_DEPRECTED_ID = "@intlify/vite-plugin-vue-i18n/messages";
const debug = createDebug("unplugin-vue-i18n");
const unplugin = createUnplugin((options = {}, meta) => {
  debug("plugin options:", options, meta.framework);
  if (!["vite", "webpack"].includes(meta.framework)) {
    raiseError(`This plugin is supported 'vite' and 'webpack' only`);
  }
  let include = options.include;
  if (include) {
    if (isArray(include)) {
      include = include.map((item) => normalize(item));
    } else if (isString(include)) {
      include = normalize(include);
    }
  }
  const filter = createFilter(include);
  const forceStringify = !!options.forceStringify;
  const defaultSFCLang = isString(options.defaultSFCLang) ? options.defaultSFCLang : "json";
  const globalSFCScope = !!options.globalSFCScope;
  const useClassComponent = !!options.useClassComponent;
  const bridge = !!options.bridge;
  debug("bridge", bridge);
  let isProduction = false;
  let sourceMap = false;
  return {
    name: "unplugin-vue-i18n",
    enforce: meta.framework === "vite" ? "pre" : "post",
    transformInclude(id) {
      debug("transformInclude", id);
      if (meta.framework === "vite") {
        return true;
      } else {
        const { filename } = parseVueRequest(id);
        return filename.endsWith("vue") || filename.endsWith(INTLIFY_BUNDLE_IMPORT_ID) || filename.endsWith(INTLIFY_BUNDLE_IMPORT_DEPRECTED_ID) ? true : /\.(json5?|ya?ml)$/.test(id) && filter(id);
      }
    },
    vite: {
      configResolved(config) {
        isProduction = config.isProduction;
        sourceMap = config.command === "build" ? !!config.build.sourcemap : false;
        debug(`configResolved: isProduction = ${isProduction}, sourceMap = ${sourceMap}`);
        const jsonPlugin = config.plugins.find((p) => p.name === "vite:json");
        if (jsonPlugin) {
          const orgTransform = jsonPlugin.transform;
          jsonPlugin.transform = async function(code, id) {
            if (!/\.json$/.test(id) || filter(id)) {
              return;
            }
            const { query } = parseVueRequest(id);
            if (query.vue) {
              return;
            }
            debug("org json plugin");
            return orgTransform.apply(this, [code, id]);
          };
        }
      }
    },
    webpack(compiler) {
      isProduction = compiler.options.mode !== "development";
      sourceMap = !!compiler.options.devtool;
      debug(`webpack: isProduction = ${isProduction}, sourceMap = ${sourceMap}`);
      if (compiler.options.module) {
        compiler.options.module.rules.push({
          test: /\.(json5?|ya?ml)$/,
          type: "javascript/auto",
          exclude: include
        });
      }
    },
    resolveId(id, importer) {
      debug("resolveId", id, importer);
      if (id === INTLIFY_BUNDLE_IMPORT_DEPRECTED_ID) {
        warn(`deprected '${INTLIFY_BUNDLE_IMPORT_DEPRECTED_ID}', you should switch to '${INTLIFY_BUNDLE_IMPORT_ID}'`);
        return id;
      }
      if (id === INTLIFY_BUNDLE_IMPORT_ID) {
        return id;
      }
    },
    async load(id) {
      debug("load", id);
      const { query } = parseVueRequest(id);
      if ([INTLIFY_BUNDLE_IMPORT_DEPRECTED_ID, INTLIFY_BUNDLE_IMPORT_ID].includes(id) && include) {
        let resourcePaths = [];
        const includePaths = isArray(include) ? include : [include];
        for (const inc of includePaths) {
          resourcePaths = [...resourcePaths, ...await fg(inc)];
        }
        resourcePaths = resourcePaths.filter((el, pos) => resourcePaths.indexOf(el) === pos);
        const code = await generateBundleResources(resourcePaths, query, isProduction, {
          forceStringify,
          bridge,
          useClassComponent
        });
        return {
          code,
          map: { mappings: "" }
        };
      }
    },
    async transform(code, id) {
      const { filename, query } = parseVueRequest(id);
      debug("transform", id, JSON.stringify(query), filename);
      let langInfo = defaultSFCLang;
      let inSourceMap;
      if (!query.vue) {
        if (/\.(json5?|ya?ml)$/.test(id) && filter(id)) {
          langInfo = parse(filename).ext;
          const generate = /\.?json5?/.test(langInfo) ? generateJSON : generateYAML;
          const parseOptions = getOptions(filename, isProduction, query, sourceMap, {
            inSourceMap,
            isGlobal: globalSFCScope,
            useClassComponent,
            bridge,
            forceStringify
          });
          debug("parseOptions", parseOptions);
          const { code: generatedCode, map } = generate(code, parseOptions, bridge ? createBridgeCodeGenerator(code, query) : void 0);
          debug("generated code", generatedCode);
          debug("sourcemap", map, sourceMap);
          if (code === generatedCode)
            return;
          return {
            code: generatedCode,
            map: sourceMap ? map : { mappings: "" }
          };
        } else {
          return {
            code,
            map: { mappings: "", version: "3", sources: [] }
          };
        }
      } else {
        if (isCustomBlock(query)) {
          if (isString(query.lang)) {
            langInfo = query.src ? query.lang === "i18n" ? "json" : query.lang : query.lang;
          } else if (defaultSFCLang) {
            langInfo = defaultSFCLang;
          }
          debug("langInfo", langInfo);
          const generate = /\.?json5?/.test(langInfo) ? generateJSON : generateYAML;
          const parseOptions = getOptions(filename, isProduction, query, sourceMap, {
            inSourceMap,
            isGlobal: globalSFCScope,
            useClassComponent,
            bridge,
            forceStringify
          });
          debug("parseOptions", parseOptions);
          const source = await getCode(code, filename, sourceMap, query, meta.framework);
          const { code: generatedCode, map } = generate(source, parseOptions, bridge ? createBridgeCodeGenerator(source, query) : void 0);
          debug("generated code", generatedCode);
          debug("sourcemap", map, sourceMap);
          if (code === generatedCode)
            return;
          return {
            code: generatedCode,
            map: sourceMap ? map : { mappings: "" }
          };
        }
      }
    }
  };
});
async function generateBundleResources(resources, query, isProduction, {
  forceStringify = false,
  isGlobal = false,
  bridge = false,
  useClassComponent = false
}) {
  const codes = [];
  for (const res of resources) {
    debug(`${res} bundle loading ...`);
    if (/\.(json5?|ya?ml)$/.test(res)) {
      const { ext, name } = parse(res);
      const source = await getRaw(res);
      const generate = /json5?/.test(ext) ? generateJSON : generateYAML;
      const parseOptions = getOptions(res, isProduction, {}, false, {
        isGlobal,
        useClassComponent,
        bridge,
        forceStringify
      });
      parseOptions.type = "bare";
      const { code } = generate(source, parseOptions, bridge ? createBridgeCodeGenerator(source, query) : void 0);
      debug("generated code", code);
      codes.push(`${JSON.stringify(name)}: ${code}`);
    }
  }
  return `export default {
  ${codes.join(`,
`)}
}`;
}
async function getCode(source, filename, sourceMap, query, framework = "vite") {
  const { index, issuerPath } = query;
  if (!isNumber(index)) {
    raiseError(`unexpected index: ${index}`);
  }
  if (framework === "webpack") {
    if (issuerPath) {
      debug(`getCode (webpack) ${index} via issuerPath`, issuerPath);
      return await getRaw(filename);
    } else {
      const result = parse$1(await getRaw(filename), {
        sourceMap,
        filename
      });
      const block = result.descriptor.customBlocks[index];
      if (block) {
        const code = block.src ? await getRaw(block.src) : block.content;
        debug(`getCode (webpack) ${index} from SFC`, code);
        return code;
      } else {
        return source;
      }
    }
  } else {
    return source;
  }
}
function isCustomBlock(query) {
  return !isEmptyObject(query) && "vue" in query && (query["type"] === "custom" || query["type"] === "i18n" || query["blockType"] === "i18n");
}
function getOptions(filename, isProduction, query, sourceMap, {
  inSourceMap = void 0,
  forceStringify = false,
  isGlobal = false,
  bridge = false,
  useClassComponent = false
}) {
  const mode = isProduction ? "production" : "development";
  const baseOptions = {
    filename,
    sourceMap,
    inSourceMap,
    forceStringify,
    useClassComponent,
    bridge,
    env: mode,
    onWarn: (msg) => {
      warn(`${filename} ${msg}`);
    },
    onError: (msg) => {
      error(`${filename} ${msg}`);
    }
  };
  if (isCustomBlock(query)) {
    return assign(baseOptions, {
      type: "sfc",
      locale: isString(query.locale) ? query.locale : "",
      isGlobal: isGlobal || !!query.global
    });
  } else {
    return assign(baseOptions, {
      type: "plain",
      isGlobal: false
    });
  }
}

export { unplugin as default, unplugin };
